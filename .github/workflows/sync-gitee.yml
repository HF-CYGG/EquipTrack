name: Sync to Gitee

on:
  release:
    types: [published]
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Push to Gitee
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Add Gitee remote with Token authentication
          # Format: https://<username>:<token>@gitee.com/<owner>/<repo>.git
          git remote add gitee "https://YeMiao_cats:${{ secrets.GITEE_TOKEN }}@gitee.com/YeMiao_cats/EquipTrack.git"
          
          # Push main branch and tags
          # Using --force to ensure Gitee stays exactly in sync with GitHub
          git push gitee main --force
          git push gitee --tags --force

      - name: Sync Releases to Gitee
        if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
        id: sync_releases
        uses: actions/github-script@v7
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
        with:
          script: |
            const owner = 'YeMiao_cats';
            const repo = 'EquipTrack';
            const fs = require('fs');
            const path = require('path');
            const manifestPath = path.join(process.env.RUNNER_TEMP || '/tmp', 'gitee-release-manifest.json');
            let giteeReleasesCache = null;

            async function getGiteeReleases() {
              if (giteeReleasesCache) return giteeReleasesCache;
              const res = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases?access_token=${process.env.GITEE_TOKEN}&page=1&per_page=100`);
              if (!res.ok) {
                console.warn(`âš ï¸ Failed to list releases: ${res.status} ${res.statusText}`);
                giteeReleasesCache = [];
                return giteeReleasesCache;
              }
              const data = await res.json();
              giteeReleasesCache = Array.isArray(data) ? data : [];
              return giteeReleasesCache;
            }

            // Helper function to sync a single release
            async function syncRelease(release) {
              const { name, body, tag_name, prerelease, assets } = release;
              console.log(`ðŸš€ Starting sync for release: ${tag_name}`);

              let giteeId = null;
              
              try {
                let existingAssets = [];

                const releasesList = await getGiteeReleases();
                const existingRelease = releasesList.find(r => r.tag_name === tag_name);
                if (existingRelease) {
                  giteeId = existingRelease.id;
                  existingAssets = existingRelease.assets || [];
                  console.log(`âœ… Found existing release ID: ${giteeId}, with ${existingAssets.length} assets.`);
                }

                // 2. Create release if not found
                if (!giteeId) {
                   console.log('â„¹ï¸ Creating new release...');
                   const createRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                     body: JSON.stringify({
                       access_token: process.env.GITEE_TOKEN,
                       tag_name, 
                       name, 
                       body, 
                       prerelease,
                       target_commitish: 'main'
                     })
                   });
                   
                   const createData = await createRes.json();
                   if (createRes.ok) {
                     console.log('âœ… Created new release on Gitee:', createData.name);
                     giteeId = createData.id;
                     if (giteeReleasesCache) {
                       giteeReleasesCache.push({ tag_name, id: giteeId, assets: [] });
                     }
                   } else {
                     console.error(`âŒ Failed to create release: ${JSON.stringify(createData)}`);
                     return;
                   }
                }
                
                const existingAssetNames = (existingAssets || []).map(a => a && a.name).filter(Boolean);
                return {
                  tag_name,
                  giteeId,
                  existingAssetNames,
                  assets: Array.isArray(assets)
                    ? assets.map(a => ({
                        name: a.name,
                        url: a.browser_download_url,
                        size: a.size,
                      }))
                    : [],
                };
              } catch (e) {
                console.error(`ðŸ”¥ Error syncing ${tag_name}: ${e.message}`);
                return null;
              }
            }

            // Main Execution Logic
            try {
              if (context.eventName === 'release') {
                 console.log('Trigger: Release Event');
                 const entry = await syncRelease(context.payload.release);
                 const manifest = entry ? [entry] : [];
                 fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
                 core.setOutput('manifest_path', manifestPath);
                 console.log(`âœ… Manifest written: ${manifestPath} (${manifest.length} releases)`);
              } else if (context.eventName === 'workflow_dispatch') {
                 console.log('Trigger: Manual Dispatch (Syncing ALL releases)');
                 
                 // Fetch all releases from GitHub
                 const releases = await github.rest.repos.listReleases({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   per_page: 100 // Adjust if you have more than 100 releases
                 });
                 
                 console.log(`Found ${releases.data.length} releases on GitHub.`);
                 
                 const manifest = [];
                 // Process in reverse order (oldest first) to maintain timeline if creating new
                 // or just iterate.
                 for (const release of releases.data.reverse()) {
                    const entry = await syncRelease(release);
                    if (entry) manifest.push(entry);
                 }

                 fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
                 core.setOutput('manifest_path', manifestPath);
                 console.log(`âœ… Manifest written: ${manifestPath} (${manifest.length} releases)`);
              }
            } catch (error) {
              core.setFailed(`Global Sync Error: ${error.message}`);
            }

      - name: Upload Release Assets to Gitee (curl)
        if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          MANIFEST_PATH: ${{ steps.sync_releases.outputs.manifest_path }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execFileSync } = require('child_process');

          const owner = 'YeMiao_cats';
          const repo = 'EquipTrack';
          const manifestPath = process.env.MANIFEST_PATH;
          const token = process.env.GITEE_TOKEN;
          const tmpDir = process.env.RUNNER_TEMP || process.cwd();

          function runCurl(args) {
            execFileSync('curl', args, { stdio: 'inherit' });
          }

          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          for (const rel of manifest) {
            const tag = rel.tag_name;
            const giteeId = rel.giteeId;
            const existing = new Set(rel.existingAssetNames || []);
            const assets = Array.isArray(rel.assets) ? rel.assets : [];

            if (!giteeId || assets.length === 0) continue;

            for (const asset of assets) {
              if (!asset || !asset.name || !asset.url) continue;
              if (existing.has(asset.name)) {
                process.stdout.write(`â© Skip ${tag}: ${asset.name}\n`);
                continue;
              }

              const safeTag = String(tag).replace(/[^a-zA-Z0-9._-]/g, '_');
              const safeName = String(asset.name).replace(/[^a-zA-Z0-9._-]/g, '_');
              const localPath = path.join(tmpDir, `${safeTag}-${Date.now()}-${safeName}`);

              try {
                process.stdout.write(`â¬‡ï¸ Download ${tag}: ${asset.name}\n`);
                runCurl([
                  '-L',
                  '--http1.1',
                  '--fail-with-body',
                  '--retry', '6',
                  '--retry-all-errors',
                  '--retry-delay', '2',
                  '--connect-timeout', '30',
                  '--max-time', '1800',
                  '-o', localPath,
                  asset.url,
                ]);

                process.stdout.write(`â¬†ï¸ Upload ${tag}: ${asset.name}\n`);
                runCurl([
                  '--http1.1',
                  '--fail-with-body',
                  '--retry', '6',
                  '--retry-all-errors',
                  '--retry-delay', '2',
                  '--connect-timeout', '30',
                  '--max-time', '3600',
                  '-sS',
                  '-X', 'POST',
                  `https://gitee.com/api/v5/repos/${owner}/${repo}/releases/${giteeId}/attach_files`,
                  '-F', `access_token=${token}`,
                  '-F', `file=@${localPath};filename=${asset.name}`,
                ]);
              } finally {
                try { fs.unlinkSync(localPath); } catch {}
              }
            }
          }
          NODE
