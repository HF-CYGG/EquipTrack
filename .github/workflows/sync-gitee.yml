name: Build, Release and Sync

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x android/gradlew

      - name: Build Release APK
        run: |
          cd android
          ./gradlew assembleRelease

      - name: Sign Release APK
        id: sign_app
        if: ${{ secrets.SIGNING_KEY != '' }}
        uses: r0adkll/sign-android-release@v1
        with:
          releaseDirectory: android/app/build/outputs/apk/release
          signingKeyBase64: ${{ secrets.SIGNING_KEY }}
          alias: ${{ secrets.ALIAS }}
          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}
          keyPassword: ${{ secrets.KEY_PASSWORD }}
        env:
          BUILD_TOOLS_VERSION: "34.0.0"

      - name: Rename APK
        run: |
          mkdir -p dist
          if [ "${{ steps.sign_app.outputs.signedReleaseFile }}" != "" ]; then
            cp "${{ steps.sign_app.outputs.signedReleaseFile }}" dist/EquipTrack-${{ github.ref_name }}.apk
          else
            cp android/app/build/outputs/apk/release/app-release-unsigned.apk dist/EquipTrack-${{ github.ref_name }}-unsigned.apk
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  sync:
    needs: build
    runs-on: ubuntu-latest
    if: always() # Run even if build/release skipped (e.g. manual dispatch without tag?) - actually needs tag for sync
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Sync Releases to Gitee
        id: sync_releases
        uses: actions/github-script@v7
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
        with:
          script: |
            const owner = 'YeMiao_cats';
            const repo = 'EquipTrack';
            const fs = require('fs');
            const path = require('path');
            const manifestPath = path.join(process.env.RUNNER_TEMP || '/tmp', 'gitee-release-manifest.json');
            let giteeReleasesCache = null;

            async function getGiteeReleases() {
              if (giteeReleasesCache) return giteeReleasesCache;
              const res = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases?access_token=${process.env.GITEE_TOKEN}&page=1&per_page=100`);
              if (!res.ok) {
                console.warn(`âš ï¸ Failed to list releases: ${res.status} ${res.statusText}`);
                giteeReleasesCache = [];
                return giteeReleasesCache;
              }
              const data = await res.json();
              giteeReleasesCache = Array.isArray(data) ? data : [];
              return giteeReleasesCache;
            }

            async function syncRelease(release) {
              const { name, body, tag_name, prerelease, assets } = release;
              console.log(`ðŸš€ Starting sync for release: ${tag_name}`);

              let giteeId = null;
              
              try {
                let existingAssets = [];
                const releasesList = await getGiteeReleases();
                const existingRelease = releasesList.find(r => r.tag_name === tag_name);
                if (existingRelease) {
                  giteeId = existingRelease.id;
                  existingAssets = existingRelease.assets || [];
                  console.log(`âœ… Found existing release ID: ${giteeId}, with ${existingAssets.length} assets.`);
                }

                if (!giteeId) {
                   console.log('â„¹ï¸ Creating new release on Gitee...');
                   const createRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                     body: JSON.stringify({
                       access_token: process.env.GITEE_TOKEN,
                       tag_name, 
                       name, 
                       body, 
                       prerelease,
                       target_commitish: 'main'
                     })
                   });
                   
                   const createData = await createRes.json();
                   if (createRes.ok) {
                     console.log('âœ… Created new release on Gitee:', createData.name);
                     giteeId = createData.id;
                     if (giteeReleasesCache) giteeReleasesCache.push({ tag_name, id: giteeId, assets: [] });
                   } else {
                     console.error(`âŒ Failed to create release: ${JSON.stringify(createData)}`);
                     return null;
                   }
                }
                
                const existingAssetNames = (existingAssets || []).map(a => a && a.name).filter(Boolean);
                return {
                  tag_name,
                  giteeId,
                  existingAssetNames,
                  assets: Array.isArray(assets)
                    ? assets.map(a => ({
                        name: a.name,
                        url: a.browser_download_url,
                        size: a.size,
                      }))
                    : [],
                };
              } catch (e) {
                console.error(`ðŸ”¥ Error syncing ${tag_name}: ${e.message}`);
                return null;
              }
            }

            try {
              if (context.eventName === 'push' && context.ref.startsWith('refs/tags/')) {
                 const tag = context.ref.replace('refs/tags/', '');
                 console.log(`Trigger: Push Tag ${tag}`);
                 // Wait a bit for GitHub Release to be fully ready?
                 await new Promise(r => setTimeout(r, 5000));
                 
                 const release = await github.rest.repos.getReleaseByTag({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   tag
                 });
                 
                 const entry = await syncRelease(release.data);
                 const manifest = entry ? [entry] : [];
                 fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
                 core.setOutput('manifest_path', manifestPath);
              } else if (context.eventName === 'workflow_dispatch') {
                 console.log('Trigger: Manual Dispatch');
                 const releases = await github.rest.repos.listReleases({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   per_page: 20
                 });
                 const manifest = [];
                 for (const release of releases.data.reverse()) {
                    const entry = await syncRelease(release);
                    if (entry) manifest.push(entry);
                 }
                 fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');
                 core.setOutput('manifest_path', manifestPath);
              }
            } catch (error) {
              core.setFailed(`Global Sync Error: ${error.message}`);
            }

      - name: Upload Release Assets to Gitee (curl)
        if: steps.sync_releases.outputs.manifest_path != ''
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          MANIFEST_PATH: ${{ steps.sync_releases.outputs.manifest_path }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execFileSync } = require('child_process');

          const owner = 'YeMiao_cats';
          const repo = 'EquipTrack';
          const manifestPath = process.env.MANIFEST_PATH;
          const token = process.env.GITEE_TOKEN;
          const tmpDir = process.env.RUNNER_TEMP || process.cwd();

          function runCurl(args) {
            try {
               execFileSync('curl', args, { stdio: 'inherit' });
            } catch (e) {
               console.error("Curl failed", e);
               // Don't exit process to allow other assets to try
            }
          }

          if (!fs.existsSync(manifestPath)) {
            console.log("No manifest found.");
            process.exit(0);
          }

          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          for (const rel of manifest) {
            const tag = rel.tag_name;
            const giteeId = rel.giteeId;
            const existing = new Set(rel.existingAssetNames || []);
            const assets = Array.isArray(rel.assets) ? rel.assets : [];

            if (!giteeId || assets.length === 0) continue;

            for (const asset of assets) {
              if (!asset || !asset.name || !asset.url) continue;
              if (existing.has(asset.name)) {
                process.stdout.write(`â© Skip ${tag}: ${asset.name}\n`);
                continue;
              }

              const safeTag = String(tag).replace(/[^a-zA-Z0-9._-]/g, '_');
              const safeName = String(asset.name).replace(/[^a-zA-Z0-9._-]/g, '_');
              const localPath = path.join(tmpDir, `${safeTag}-${Date.now()}-${safeName}`);

              try {
                process.stdout.write(`â¬‡ï¸ Download ${tag}: ${asset.name}\n`);
                runCurl([
                  '-L',
                  '--http1.1',
                  '--fail-with-body',
                  '--retry', '6',
                  '--retry-all-errors',
                  '--retry-delay', '2',
                  '--connect-timeout', '30',
                  '--max-time', '1800',
                  '-o', localPath,
                  asset.url,
                ]);

                if (fs.existsSync(localPath)) {
                  process.stdout.write(`â¬†ï¸ Upload ${tag}: ${asset.name}\n`);
                  runCurl([
                    '--http1.1',
                    '--fail-with-body',
                    '--retry', '6',
                    '--retry-all-errors',
                    '--retry-delay', '2',
                    '--connect-timeout', '30',
                    '--max-time', '3600',
                    '-sS',
                    '-X', 'POST',
                    `https://gitee.com/api/v5/repos/${owner}/${repo}/releases/${giteeId}/attach_files`,
                    '-F', `access_token=${token}`,
                    '-F', `file=@${localPath};filename=${asset.name}`,
                  ]);
                } else {
                  console.error(`âŒ Download failed for ${asset.name}`);
                }
              } finally {
                try { fs.unlinkSync(localPath); } catch {}
              }
            }
          }
          NODE
