name: Sync to Gitee

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Sync Releases to Gitee
        id: sync_releases
        uses: actions/github-script@v7
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
        with:
          script: |
            const owner = 'YeMiao_cats';
            const repo = 'EquipTrack';
            const fs = require('fs');
            const path = require('path');
            const manifestPath = path.join(process.env.RUNNER_TEMP || '/tmp', 'gitee-release-manifest.json');
            
            // 1. èŽ·å– Gitee çŽ°æœ‰ Releases
            async function getGiteeReleases() {
              const res = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases?access_token=${process.env.GITEE_TOKEN}&page=1&per_page=20`);
              if (!res.ok) return [];
              return await res.json();
            }

            // 2. åŒæ­¥å•ä¸ª Release
            async function syncRelease(release) {
              const { name, body, tag_name, prerelease, assets } = release;
              console.log(`Processing release: ${tag_name}`);

              const giteeReleases = await getGiteeReleases();
              let targetRelease = giteeReleases.find(r => r.tag_name === tag_name);
              let giteeId = targetRelease ? targetRelease.id : null;

              // å¦‚æžœ Gitee ä¸å­˜åœ¨è¯¥ Releaseï¼Œåˆ™åˆ›å»º
              if (!giteeId) {
                console.log(`Creating release ${tag_name} on Gitee...`);
                const createRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                  body: JSON.stringify({
                    access_token: process.env.GITEE_TOKEN,
                    tag_name, name, body, prerelease,
                    target_commitish: 'main'
                  })
                });
                if (createRes.ok) {
                  const data = await createRes.json();
                  giteeId = data.id;
                  console.log(`Created Gitee release ID: ${giteeId}`);
                } else {
                  console.error('Failed to create release on Gitee');
                  return null;
                }
              }

              // å‡†å¤‡éœ€è¦ä¸Šä¼ çš„ Assets
              const existingAssets = targetRelease ? (targetRelease.assets || []) : [];
              const existingNames = new Set(existingAssets.map(a => a.name));
              
              const assetsToUpload = (assets || []).map(a => ({
                name: a.name,
                url: a.browser_download_url
              })).filter(a => !existingNames.has(a.name));

              return {
                tag_name,
                giteeId,
                assets: assetsToUpload
              };
            }

            // Main Logic
            try {
              let entries = [];
              if (context.eventName === 'release') {
                const entry = await syncRelease(context.payload.release);
                if (entry) entries.push(entry);
              } else if (context.eventName === 'workflow_dispatch') {
                const releases = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 5
                });
                // åªåŒæ­¥æœ€æ–°çš„ 5 ä¸ª
                for (const rel of releases.data) {
                   const entry = await syncRelease(rel);
                   if (entry) entries.push(entry);
                }
              }
              
              fs.writeFileSync(manifestPath, JSON.stringify(entries, null, 2));
              core.setOutput('manifest_path', manifestPath);
            } catch (err) {
              core.setFailed(err.message);
            }

      - name: Upload Assets to Gitee
        if: steps.sync_releases.outputs.manifest_path != ''
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          MANIFEST_PATH: ${{ steps.sync_releases.outputs.manifest_path }}
        run: |
          # Check if jq is installed (should be on ubuntu-latest)
          if ! command -v jq &> /dev/null; then
              sudo apt-get update && sudo apt-get install -y jq
          fi

          cat "$MANIFEST_PATH" | jq -c '.[]' | while read -r rel; do
            gitee_id=$(echo "$rel" | jq -r '.giteeId')
            tag_name=$(echo "$rel" | jq -r '.tag_name')
            
            if [ "$gitee_id" == "null" ]; then
              echo "Skipping $tag_name: No Gitee ID found."
              continue
            fi

            echo "$rel" | jq -c '.assets[]' | while read -r asset; do
              name=$(echo "$asset" | jq -r '.name')
              url=$(echo "$asset" | jq -r '.url')
              
              if [ -z "$name" ] || [ "$name" == "null" ]; then continue; fi

              echo "ðŸ“¦ Processing $name for $tag_name..."
              
              # 1. Download from GitHub
              echo "   â¬‡ï¸ Downloading..."
              if curl -L -o "$name" "$url" --retry 5 --retry-delay 5 --fail; then
                  echo "   âœ… Downloaded."
              else
                  echo "   âŒ Failed to download $name"
                  continue
              fi

              # 2. Upload to Gitee
              echo "   â¬†ï¸ Uploading to Gitee..."
              # Use a temporary file for response to check status
              resp_file=$(mktemp)
              http_code=$(curl -o "$resp_file" -w "%{http_code}" -X POST \
                "https://gitee.com/api/v5/repos/YeMiao_cats/EquipTrack/releases/$gitee_id/attach_files" \
                -F "access_token=$GITEE_TOKEN" \
                -F "file=@$name" \
                --retry 3 \
                --retry-delay 5 \
                --connect-timeout 60 \
                --max-time 1800)
              
              if [ "$http_code" -eq 201 ] || [ "$http_code" -eq 200 ]; then
                  echo "   âœ… Upload success ($http_code)"
              else
                  echo "   âŒ Upload failed ($http_code)"
                  cat "$resp_file"
                  # Attempt fallback: Delete and Retry once if it's a conflict? 
                  # Usually 400/500 errors. Gitee might return 403 if token invalid.
              fi
              
              rm -f "$name" "$resp_file"
            done
          done

      - name: Sync Code to Gitee
        if: always()
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git remote remove gitee 2>/dev/null || true
          git remote add gitee https://YeMiao_cats:${{ secrets.GITEE_TOKEN }}@gitee.com/YeMiao_cats/EquipTrack.git
          git fetch origin main
          git push gitee origin/main:main --force
          git push gitee --tags --force
