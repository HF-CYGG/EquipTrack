name: Sync to Gitee

on:
  release:
    types: [published]
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Push to Gitee
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # Add Gitee remote with Token authentication
          # Format: https://<username>:<token>@gitee.com/<owner>/<repo>.git
          git remote add gitee "https://YeMiao_cats:${{ secrets.GITEE_TOKEN }}@gitee.com/YeMiao_cats/EquipTrack.git"
          
          # Push main branch and tags
          # Using --force to ensure Gitee stays exactly in sync with GitHub
          git push gitee main --force
          git push gitee --tags --force

      - name: Sync Releases to Gitee
        if: github.event_name == 'release' || github.event_name == 'workflow_dispatch'
        uses: actions/github-script@v7
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
        with:
          script: |
            const owner = 'YeMiao_cats';
            const repo = 'EquipTrack';

            // Helper function to sync a single release
            async function syncRelease(release) {
              const { name, body, tag_name, prerelease, assets } = release;
              console.log(`üöÄ Starting sync for release: ${tag_name}`);

              let giteeId = null;
              
              try {
                // 1. Try to get existing release first
                let createRes = null;
                const getRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases/tags/${encodeURIComponent(tag_name)}?access_token=${process.env.GITEE_TOKEN}`);
                
                if (getRes.ok) {
                   const getData = await getRes.json();
                   giteeId = getData.id;
                   console.log('‚úÖ Found existing release ID:', giteeId);
                } else if (getRes.status === 404) {
                   console.log('‚ÑπÔ∏è Release not found, creating new one...');
                   // 2. Create release if not found
                   createRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases`, {
                     method: 'POST',
                     headers: { 'Content-Type': 'application/json;charset=UTF-8' },
                     body: JSON.stringify({
                       access_token: process.env.GITEE_TOKEN,
                       tag_name, 
                       name, 
                       body, 
                       prerelease,
                       target_commitish: 'main' // Required by Gitee API
                     })
                   });
                   
                   const createData = await createRes.json();
                   if (createRes.ok) {
                     console.log('‚úÖ Created new release on Gitee:', createData.name);
                     giteeId = createData.id;
                   } else {
                     console.error(`‚ùå Failed to create release: ${JSON.stringify(createData)}`);
                     return;
                   }
                } else {
                   console.error(`‚ùå Failed to check for existing release: ${getRes.status} ${getRes.statusText}`);
                   return;
                }
                
                // 2. Upload Assets
                if (giteeId && assets && assets.length > 0) {
                  console.log(`üì¶ Found ${assets.length} assets to sync.`);
                  
                  for (const asset of assets) {
                    // Check if asset already exists on Gitee (optional optimization, but Gitee might just reject duplicates)
                    // For simplicity, we try to upload and handle errors.
                    
                    console.log(`‚¨áÔ∏è Downloading ${asset.name} from GitHub...`);
                    // GitHub assets require correct headers or redirects handling
                    // Using a simpler fetch might fail on redirects or auth for private repos (though releases are usually public)
                    const fileRes = await fetch(asset.browser_download_url);
                    if (!fileRes.ok) {
                       console.warn(`‚ö†Ô∏è Failed to download ${asset.name}: ${fileRes.status} ${fileRes.statusText}`);
                       continue;
                    }
                    const arrayBuffer = await fileRes.arrayBuffer();
                    // Convert to Blob for standard FormData
                    const blob = new Blob([arrayBuffer], { type: asset.content_type || 'application/octet-stream' });
                    
                    console.log(`‚¨ÜÔ∏è Uploading ${asset.name} to Gitee...`);
                    const formData = new FormData();
                    formData.append('access_token', process.env.GITEE_TOKEN);
                    formData.append('file', blob, asset.name);
                    
                    const uploadRes = await fetch(`https://gitee.com/api/v5/repos/${owner}/${repo}/releases/${giteeId}/attach_files`, {
                      method: 'POST',
                      body: formData
                    });
                    
                    if (uploadRes.ok) {
                       console.log(`‚úÖ Uploaded ${asset.name}`);
                    } else {
                       const uploadData = await uploadRes.json();
                       // Ignore if file already exists error
                       if (uploadData.message && uploadData.message.includes('Â∑≤Â≠òÂú®')) {
                          console.log(`‚ÑπÔ∏è Asset ${asset.name} already exists.`);
                       } else {
                          console.warn(`‚ö†Ô∏è Failed to upload ${asset.name}:`, uploadData);
                       }
                    }
                  }
                } else {
                   console.log('‚ÑπÔ∏è No assets to upload or Release ID missing.');
                }
              } catch (e) {
                console.error(`üî• Error syncing ${tag_name}: ${e.message}`);
              }
            }

            // Main Execution Logic
            try {
              if (context.eventName === 'release') {
                 console.log('Trigger: Release Event');
                 await syncRelease(context.payload.release);
              } else if (context.eventName === 'workflow_dispatch') {
                 console.log('Trigger: Manual Dispatch (Syncing ALL releases)');
                 
                 // Fetch all releases from GitHub
                 const releases = await github.rest.repos.listReleases({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   per_page: 100 // Adjust if you have more than 100 releases
                 });
                 
                 console.log(`Found ${releases.data.length} releases on GitHub.`);
                 
                 // Process in reverse order (oldest first) to maintain timeline if creating new
                 // or just iterate.
                 for (const release of releases.data.reverse()) {
                    await syncRelease(release);
                 }
              }
            } catch (error) {
              core.setFailed(`Global Sync Error: ${error.message}`);
            }
